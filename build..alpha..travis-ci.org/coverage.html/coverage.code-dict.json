{"/home/travis/build/npmtest/node-npmtest-dynamoose/test.js":"/* istanbul instrument in package npmtest_dynamoose */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-dynamoose/lib.npmtest_dynamoose.js":"/* istanbul instrument in package npmtest_dynamoose */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_dynamoose = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_dynamoose = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-dynamoose/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-dynamoose && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_dynamoose */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_dynamoose\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_dynamoose.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_dynamoose.rollup.js'] =\n            local.assetsDict['/assets.npmtest_dynamoose.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_dynamoose.__dirname + '/lib.npmtest_dynamoose.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-dynamoose/node_modules/dynamoose/index.js":"exports = module.exports = require('./lib');\n","/home/travis/build/npmtest/node-npmtest-dynamoose/node_modules/dynamoose/lib/index.js":"'use strict';\n\nvar Schema = require('./Schema');\nvar Model = require('./Model');\n\nvar debug = require('debug')('dynamoose');\n\nfunction Dynamoose () {\n  this.models = {};\n\n  this.defaults = {\n    create: true,\n    waitForActive: true, // Wait for table to be created\n    waitForActiveTimeout: 180000, // 3 minutes\n    prefix: ''\n  }; // defaults\n}\n\nDynamoose.prototype.model = function(name, schema, options) {\n  options = options || {};\n\n  for(var key in this.defaults) {\n    options[key] = (typeof options[key] === 'undefined') ? this.defaults[key] : options[key];\n  }\n\n  name = options.prefix + name;\n\n  debug('Looking up model %s', name);\n\n  if(this.models[name]) {\n    return this.models[name];\n  }\n  if (!(schema instanceof Schema)) {\n    schema = new Schema(schema, options);\n  }\n\n  var model = Model.compile(name, schema, options, this);\n  this.models[name] = model;\n  return model;\n};\n\n/**\n * The Mongoose [VirtualType](#virtualtype_VirtualType) constructor\n *\n * @method VirtualType\n * @api public\n */\n\nDynamoose.prototype.VirtualType = require('./VirtualType');\n\nDynamoose.prototype.AWS = require('aws-sdk');\n\nDynamoose.prototype.local = function (url) {\n  this.endpointURL = url || 'http://localhost:8000';\n  debug('Setting DynamoDB to local (%s)', this.endpointURL);\n};\n\nDynamoose.prototype.ddb = function () {\n  if(this.dynamoDB) {\n    return this.dynamoDB;\n  }\n  if(this.endpointURL) {\n    debug('Setting DynamoDB to %s', this.endpointURL);\n    this.dynamoDB = new this.AWS.DynamoDB({ endpoint: new this.AWS.Endpoint(this.endpointURL) });\n  } else {\n    debug('Getting default DynamoDB');\n    this.dynamoDB = new this.AWS.DynamoDB();\n  }\n  return this.dynamoDB;\n};\n\nDynamoose.prototype.setDefaults = function (options) {\n\n  for(var key in this.defaults) {\n    options[key] = (typeof options[key] === 'undefined') ? this.defaults[key] : options[key];\n  }\n\n  this.defaults = options;\n};\n\nDynamoose.prototype.Schema = Schema;\nDynamoose.prototype.Table = require('./Table');\nDynamoose.prototype.Dynamoose = Dynamoose;\n\nmodule.exports = new Dynamoose();\n","/home/travis/build/npmtest/node-npmtest-dynamoose/node_modules/dynamoose/lib/Schema.js":"'use strict';\n\nvar Attribute = require('./Attribute');\nvar errors = require('./errors');\nvar VirtualType = require('./VirtualType');\n//var util = require('util');\n\nvar debug = require('debug')('dynamoose:schema');\n\n\n\nfunction Schema(obj, options) {\n  debug('Creating Schema', obj);\n\n  this.options = options || {};\n\n  this.methods = {};\n  this.statics = {};\n  this.virtuals = {};\n  this.tree = {};\n\n  if(this.options.throughput) {\n    var throughput = this.options.throughput;\n    if(typeof throughput === 'number') {\n      throughput = {read: throughput, write: throughput};\n    }\n    this.throughput = throughput;\n  } else {\n    this.throughput = {read: 1, write: 1};\n  }\n\n  if((!this.throughput.read || !this.throughput.write) &&\n    this.throughput.read >= 1 && this.throughput.write >= 1) {\n    throw new errors.SchemaError('Invalid throughput: '+ this.throughput);\n  }\n\n  /*\n    * Added support for timestamps attribute\n    */\n  if (this.options.timestamps) {\n    var createdAt = null;\n    var updatedAt = null;\n\n    if (this.options.timestamps === true) {\n      createdAt = 'createdAt';\n      updatedAt = 'updatedAt';\n    } else if (typeof this.options.timestamps === 'object') {\n      if (this.options.timestamps.createdAt && this.options.timestamps.updatedAt) {\n        createdAt = this.options.timestamps.createdAt;\n        updatedAt = this.options.timestamps.updatedAt;\n      } else {\n        throw new errors.SchemaError('Missing createdAt and updatedAt timestamps attribute. Maybe set timestamps: true?');\n      }\n    } else {\n      throw new errors.SchemaError('Invalid syntax for timestamp: ' + name);\n    }\n\n    obj[createdAt] = { type: Date, default: Date.now };\n    obj[updatedAt] = { type: Date, default: Date.now, set: function() { return Date.now(); } };\n    this.timestamps = { createdAt: createdAt, updatedAt: updatedAt };\n  }\n\n  this.useDocumentTypes = !!this.options.useDocumentTypes;\n\n  this.attributes = {};\n  this.indexes = {local: {}, global: {}};\n\n  for(var n in obj) {\n\n    if(this.attributes[n]) {\n      throw new errors.SchemaError('Duplicate attribute: ' + n);\n    }\n\n    debug('Adding Attribute to Schema (%s)', n, obj);\n    this.attributes[n] = Attribute.create(this, n, obj[n]);\n  }\n}\n\n/*Schema.prototype.attribute = function(name, obj) {\n  debug('Adding Attribute to Schema (%s)', name, obj);\n\n  this Attribute.create(name, obj);\n\n};*/\n\nSchema.prototype.toDynamo = function(model) {\n\n  var dynamoObj = {};\n  //debug('toDynamo with schema attributes', this.attributes);\n  for(var name in this.attributes) {\n    var attr = this.attributes[name];\n    attr.setDefault(model);\n    var dynamoAttr = attr.toDynamo(model[name], undefined, model);\n    if(dynamoAttr) {\n      dynamoObj[attr.name] = dynamoAttr;\n    }\n  }\n\n  debug('toDynamo: %s', JSON.stringify(dynamoObj) );\n  return dynamoObj;\n};\n\nSchema.prototype.parseDynamo = function(model, dynamoObj) {\n\n  for(var attrName in this.attributes) {\n    var attrVal = this.attributes[attrName].parseDynamo(dynamoObj[attrName]);\n    if(attrVal !== undefined && attrVal !== null){\n      model[attrName] = attrVal;\n    }\n  }\n\n  debug('parseDynamo: %s',JSON.stringify(model));\n\n  return dynamoObj;\n\n};\n\n/**\n * Adds an instance method to documents constructed from Models compiled from this schema.\n *\n * ####Example\n *\n *     var schema = kittySchema = new Schema(..);\n *\n *     schema.method('meow', function () {\n *       console.log('meeeeeoooooooooooow');\n *     })\n *\n *     var Kitty = mongoose.model('Kitty', schema);\n *\n *     var fizz = new Kitty;\n *     fizz.meow(); // meeeeeooooooooooooow\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.method({\n *         purr: function () {}\n *       , scratch: function () {}\n *     });\n *\n *     // later\n *     fizz.purr();\n *     fizz.scratch();\n *\n * @param {String|Object} method name\n * @param {Function} [fn]\n * @api public\n */\n\nSchema.prototype.method = function (name, fn) {\n  if (typeof name !== 'string' ){\n    for (var i in name){\n      this.methods[i] = name[i];\n    }\n  } else {\n    this.methods[name] = fn;\n  }\n  return this;\n};\n\n/**\n * Adds static \"class\" methods to Models compiled from this schema.\n *\n * ####Example\n *\n *     var schema = new Schema(..);\n *     schema.static('findByName', function (name, callback) {\n *       return this.find({ name: name }, callback);\n *     });\n *\n *     var Drink = mongoose.model('Drink', schema);\n *     Drink.findByName('sanpellegrino', function (err, drinks) {\n *       //\n *     });\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n *\n * @param {String} name\n * @param {Function} fn\n * @api public\n */\n\nSchema.prototype.static = function(name, fn) {\n  if (typeof name !== 'string' ){\n    for (var i in name){\n      this.statics[i] = name[i];\n    }\n  } else {\n    this.statics[name] = fn;\n  }\n  return this;\n};\n\n\n/**\n * Creates a virtual type with the given name.\n *\n * @param {String} name\n * @param {Object} [options]\n * @return {VirtualType}\n */\n\nSchema.prototype.virtual = function (name, options) {\n  //var virtuals = this.virtuals;\n  var parts = name.split('.');\n\n  return this.virtuals[name] = parts.reduce(function (mem, part, i) {\n    mem[part] || (mem[part] = (i === parts.length-1) ? new VirtualType(options, name) : {});\n    return mem[part];\n  }, this.tree);\n};\n\n/**\n * Returns the virtual type with the given `name`.\n *\n * @param {String} name\n * @return {VirtualType}\n */\n\nSchema.prototype.virtualpath = function (name) {\n  return this.virtuals[name];\n};\n\n\nmodule.exports = Schema;\n","/home/travis/build/npmtest/node-npmtest-dynamoose/node_modules/dynamoose/lib/Attribute.js":"'use strict';\nvar debug = require('debug')('dynamoose:attribute');\n\nvar util = require('util');\n\nvar errors = require('./errors');\n\nfunction Attribute(schema, name, value) {\n  this.options = {};\n\n  debug('Creating attribute %s %o', name, value);\n  if (value.type){\n    this.options = value;\n  }\n\n  this.schema = schema;\n\n  this.name = name;\n\n  this.setType(value);\n\n  if(!schema.useDocumentTypes) {\n    if(this.type.name === 'map') {\n      debug('Overwriting attribute %s type to object', name);\n      this.type = this.types.object;\n    } else if (this.type.name === 'list') {\n      debug('Overwriting attribute %s type to array', name);\n      this.type = this.types.array;\n    }\n  }\n\n  this.attributes = {};\n\n  if ( this.type.name === 'map'){\n\n    if(value.type) {\n      value = value.map;\n    }\n    for (var subattrName in value){\n      if(this.attributes[subattrName]) {\n        throw new errors.SchemaError('Duplicate attribute: ' + subattrName + ' in ' + this.name);\n      }\n\n      this.attributes[subattrName] = module.exports.create(schema, subattrName, value[subattrName]);\n    }\n\n  }\n  else if (this.type.name === 'list'){\n\n    if(value.type) {\n      value = value.list;\n    }\n\n    if (value === undefined && value[0] === undefined){\n      throw new errors.SchemaError('No object given for attribute:' + this.name );\n    }\n\n    if (value.length > 1){\n      throw new errors.SchemaError('Only one object can be defined as a list type in ' + this.name );\n    }\n\n\n    for (var i = 0; i < value.length; i++) {\n      this.attributes[i] = module.exports.create(schema, 0, value[i]);\n    }\n\n  }\n\n  if (this.options){\n    this.applyDefault(this.options.default);\n\n    this.required = this.options.required;\n    this.set = this.options.set;\n    this.get = this.options.get;\n\n    this.applyValidation(this.options.validate);\n\n    this.applyIndexes(this.options.index);\n  }\n}\n\n\nfunction datify(v) {\n  if(!v.getTime) {\n    v = new Date(v);\n  }\n  return JSON.stringify(v.getTime());\n}\n\nAttribute.prototype.types = {\n  string: {\n    name: 'string',\n    dynamo: 'S'\n  },\n  number: {\n    name: 'number',\n    dynamo: 'N'\n  },\n  boolean: {\n    name: 'boolean',\n    dynamo: 'S',\n    dynamofy: JSON.stringify\n  },\n  date: {\n    name: 'date',\n    dynamo: 'N',\n    dynamofy: datify\n  },\n  object: {\n    name: 'object',\n    dynamo: 'S',\n    dynamofy: JSON.stringify\n  },\n  array: {\n    name: 'array',\n    dynamo: 'S',\n    dynamofy: JSON.stringify\n  },\n  map: {\n    name: 'map',\n    dynamo: 'M',\n    dynamofy: JSON.stringify\n  },\n  list: {\n    name: 'list',\n    dynamo: 'L',\n    dynamofy: JSON.stringify\n  },\n  buffer: {\n    name: 'buffer',\n    dynamo: 'B'\n  }\n};\n\nAttribute.prototype.setType = function(value) {\n  if(!value) {\n    throw new errors.SchemaError('Invalid attribute value: ' + value);\n  }\n\n  var type;\n  var typeVal = value;\n  if (value.type){\n    typeVal = value.type;\n  }\n\n  if (util.isArray(typeVal) && typeVal.length === 1 && typeof typeVal[0] === 'object'){\n     type = 'List';\n  } else if ( (util.isArray(typeVal) && typeVal.length === 1) || typeof typeVal === 'function') {\n    this.isSet = util.isArray(typeVal);\n    var regexFuncName = /^Function ([^(]+)\\(/i;\n    var found = typeVal.toString().match(regexFuncName);\n    type = found[1];\n  } else if (typeof typeVal === 'object'){\n    type = 'Map';\n  } else if (typeof typeVal === 'string') {\n    type = typeVal;\n  }\n\n  if(!type) {\n    throw new errors.SchemaError('Invalid attribute type: ' + type);\n  }\n\n  type = type.toLowerCase();\n\n  this.type = this.types[type];\n\n  if(!this.type) {\n    throw new errors.SchemaError('Invalid attribute type: ' + type);\n  }\n\n};\n\nAttribute.prototype.applyDefault = function(dflt) {\n  if(dflt === null || dflt === undefined){\n    delete this.default;\n  } else if(typeof dflt === 'function') {\n    this.default = dflt;\n  } else {\n    this.default = function() {\n      return dflt;\n    };\n  }\n};\n\nAttribute.prototype.applyValidation = function(validator) {\n  if(validator === null || validator === undefined) {\n    delete this.validator;\n  } else if(typeof validator === 'function') {\n    this.validator = validator;\n  } else if(validator.constructor.name === 'RegExp') {\n    this.validator = function (val) {\n      return validator.test(val);\n    };\n  } else {\n    this.validator = function (val) {\n      return validator === val;\n    };\n  }\n};\n\nAttribute.prototype.applyIndexes = function(indexes) {\n  if(indexes === null || indexes === undefined) {\n    delete this.indexes;\n    return;\n  }\n\n  var attr = this;\n  attr.indexes = {};\n\n  function applyIndex(i) {\n    if(typeof i !== 'object') {\n      i = {};\n    }\n\n    var index = {};\n\n    if(i.global) {\n      index.global = true;\n\n      if(i.rangeKey) {\n        index.rangeKey = i.rangeKey;\n      }\n\n      if(i.throughput) {\n        var throughput = i.throughput;\n        if(typeof throughput === 'number') {\n          throughput = {read: throughput, write: throughput};\n        }\n        index.throughput = throughput;\n        if((!index.throughput.read || !index.throughput.write) &&\n          index.throughput.read >= 1 && index.throughput.write >= 1) {\n          throw new errors.SchemaError('Invalid Index throughput: '+ index.throughput);\n        }\n      } else {\n        index.throughput = attr.schema.throughput;\n      }\n    }\n\n    if(i.name) {\n      index.name = i.name;\n    } else {\n      index.name = attr.name + (i.global ? 'GlobalIndex' : 'LocalIndex');\n    }\n\n    if(i.project !== null && i.project !== undefined) {\n      index.project = i.project;\n    } else {\n      index.project = true;\n    }\n\n\n    if(attr.indexes[index.name]) {\n      throw new errors.SchemaError('Duplicate index names: ' + index.name);\n    }\n    attr.indexes[index.name] = index;\n  }\n\n  if(util.isArray(indexes)) {\n    indexes.map(applyIndex);\n  } else {\n    applyIndex(indexes);\n  }\n};\n\nAttribute.prototype.setDefault = function(model) {\n  if (model === undefined || model === null){ return;}\n  var val = model[this.name];\n  if((val === null || val === undefined || val === '') && this.default) {\n    model[this.name] = this.default();\n    debug('Defaulted %s to %s', this.name,  model[this.name]);\n  }\n};\n\nAttribute.prototype.toDynamo = function(val, noSet, model) {\n\n  if(val === null || val === undefined || val === '') {\n    if(this.required) {\n      throw new errors.ValidationError('Required value missing: ' + this.name);\n    }\n    return null;\n  }\n\n  if(!noSet && this.isSet){\n    if(!util.isArray(val)) {\n      throw new errors.ValidationError('Values must be array: ' + this.name);\n    }\n    if(val.length === 0) {\n      return null;\n    }\n  }\n\n  if(this.validator && !this.validator(val)) {\n    throw new errors.ValidationError('Validation failed: ' + this.name);\n  }\n\n  if(this.set) {\n    val = this.set(val);\n  }\n\n\n\n  var type = this.type;\n\n  var isSet = this.isSet && !noSet;\n  var dynamoObj = {};\n\n  if(isSet) {\n    dynamoObj[type.dynamo + 'S'] = val.map(function(v) {\n      if(type.dynamofy) {\n        return type.dynamofy(v);\n      }\n      v = v.toString();\n      if(type.dynamo === 'S') {\n        if(this.options.trim) {\n          v = v.trim();\n        }\n        if(this.options.lowercase) {\n          v = v.toLowerCase();\n        }\n        if(this.options.uppercase) {\n          v = v.toUpperCase();\n        }\n      }\n\n      return v;\n    }.bind(this));\n  } else if (type.name === 'map') {\n\n    var dynamoMapObj = {};\n    for(var name in this.attributes) {\n      var attr = this.attributes[name];\n      attr.setDefault(model);\n      var dynamoAttr = attr.toDynamo(val[name], undefined, model);\n      if(dynamoAttr) {\n        dynamoMapObj[attr.name] = dynamoAttr;\n      }\n    }\n    dynamoObj.M = dynamoMapObj;\n\n  } else if (type.name === 'list') {\n\n    if(!util.isArray(val)) {\n      throw new errors.ValidationError('Values must be array in a `list`: ' + this.name);\n    }\n\n    var dynamoList = [];\n\n    for (var i = 0; i < val.length; i++) {\n      var item = val[i];\n\n      // TODO currently only supports one attribute type\n      var objAttr = this.attributes[0];\n      if (objAttr){\n        objAttr.setDefault(model);\n        dynamoList.push(objAttr.toDynamo(item, undefined, model));\n      }\n    }\n    dynamoObj.L = dynamoList;\n\n  } else {\n\n    if(type.dynamofy) {\n      val = type.dynamofy(val);\n    }\n\n    val = val.toString();\n    if(type.dynamo === 'S') {\n      if(this.options.trim) {\n        val = val.trim();\n      }\n      if(this.options.lowercase) {\n        val = val.toLowerCase();\n      }\n      if(this.options.uppercase) {\n        val = val.toUpperCase();\n      }\n    }\n    dynamoObj[type.dynamo] = val;\n  }\n\n  debug('toDynamo %j', dynamoObj);\n\n  return dynamoObj;\n};\n\n\nAttribute.prototype.parseDynamo = function(json) {\n\n  function dedynamofy(type, isSet, json, transform, attr) {\n    if(!json){\n      return;\n    }\n    if(isSet) {\n      var set = json[type + 'S'];\n      return set.map(function (v) {\n        if(transform) {\n          return transform(v);\n        }\n        return v;\n      });\n    }\n    var val = json[type];\n    if(transform) {\n      return transform((val !== undefined)?val:json, attr);\n    }\n    return val;\n  }\n\n  function mapify(v, attr){\n    if(!v){ return; }\n    var val = {};\n\n    for(var attrName in attr.attributes) {\n        var attrVal = attr.attributes[attrName].parseDynamo(v[attrName]);\n        if(attrVal !== undefined && attrVal !== null){\n          val[attrName] = attrVal;\n        }\n      }\n    return val;\n  }\n\n  function listify(v, attr){\n    if(!v){ return; }\n    var val = [];\n    debug('parsing list');\n\n    if (util.isArray(v)){\n\n      for (var i = 0; i < v.length ; i++){\n        // TODO assume only one attribute type allowed for a list\n        var attrType = attr.attributes[0];\n        var attrVal = attrType.parseDynamo(v[i]);\n        if(attrVal !== undefined && attrVal !== null){\n          val.push(attrVal);\n        }\n      }\n    }\n    return val;\n  }\n\n  function datify(v) {\n    debug('parsing date from %s', v);\n    return new Date(parseInt(v, 10));\n  }\n  function bufferify(v) {\n    return new Buffer(v);\n  }\n  function stringify(v){\n    if (typeof v !== 'string'){\n      debug('******', v);\n      return JSON.stringify(v);\n    }\n    return v;\n  }\n\n\n  var val;\n\n  switch(this.type.name) {\n    case 'string':\n      val = dedynamofy('S', this.isSet, json, stringify);\n      break;\n    case 'number':\n      val = dedynamofy('N', this.isSet, json, JSON.parse);\n      break;\n    case 'boolean':\n      val = dedynamofy('S', this.isSet, json, JSON.parse);\n      break;\n    case 'date':\n      val = dedynamofy('N', this.isSet, json, datify);\n      break;\n    case 'object':\n      val = dedynamofy('S', this.isSet, json, JSON.parse);\n      break;\n    case 'array':\n      val = dedynamofy('S', this.isSet, json, JSON.parse);\n      break;\n    case 'map':\n      val = dedynamofy('M', this.isSet, json, mapify, this);\n      break;\n    case 'list':\n      val = dedynamofy('L', this.isSet, json, listify, this);\n      break;\n    case 'buffer':\n      val = dedynamofy('B', this.isSet, json, bufferify);\n      break;\n    default:\n      throw new errors.SchemaError('Invalid attribute type: ' + this.type);\n  }\n\n  if(this.get) {\n    val = this.get(val);\n  }\n\n  debug('parseDynamo: %s : \"%s\" : %j', this.name, this.type.name, val);\n\n  return val;\n};\n\n\n\nmodule.exports.create = function(schema, name, obj) {\n\n\n  var value = obj;\n  var options = {};\n  if(typeof obj === 'object' && obj.type) {\n    options = obj;\n  }\n\n  var attr = new Attribute(schema, name, value);\n\n  if(options.hashKey && options.rangeKey) {\n    throw new errors.SchemaError('Cannot be both hashKey and rangeKey: ' + name);\n  }\n\n  if(options.hashKey || (!schema.hashKey && !options.rangeKey)) {\n    schema.hashKey = attr;\n  }\n\n  if(options.rangeKey) {\n    schema.rangeKey = attr;\n  }\n\n  // check for global attributes in the tree..\n  if(attr.indexes) {\n    for(var indexName in attr.indexes) {\n      var index = attr.indexes[indexName];\n      if(schema.indexes.global[indexName] || schema.indexes.local[indexName]) {\n        throw new errors.SchemaError('Duplicate index name: ' + indexName);\n      }\n      if(index.global) {\n        schema.indexes.global[indexName] = attr;\n      } else {\n        schema.indexes.local[indexName] = attr;\n      }\n    }\n  }\n\n  return attr;\n};\n\n\n//module.exports = Attribute;","/home/travis/build/npmtest/node-npmtest-dynamoose/node_modules/dynamoose/lib/errors.js":"'use strict';\n\nvar util = require('util');\n\nfunction SchemaError(message) {\n  Error.call(this); //super constructor\n  Error.captureStackTrace(this, this.constructor); //super helper method to include stack trace in error object\n\n  this.name = this.constructor.name; //set our function’s name as error name.\n  this.message = message || 'Error with schema';\n}\nutil.inherits(SchemaError, Error);\n\nfunction ModelError(message) {\n  Error.call(this); //super constructor\n  Error.captureStackTrace(this, this.constructor); //super helper method to include stack trace in error object\n\n  this.name = this.constructor.name; //set our function’s name as error name.\n  this.message = message || 'Error with model';\n}\nutil.inherits(SchemaError, Error);\n\n\nfunction QueryError(message) {\n  Error.call(this); //super constructor\n  Error.captureStackTrace(this, this.constructor); //super helper method to include stack trace in error object\n\n  this.name = this.constructor.name; //set our function’s name as error name.\n  this.message = message || 'Error with query';\n}\nutil.inherits(QueryError, Error);\n\n\nfunction ScanError(message) {\n  Error.call(this); //super constructor\n  Error.captureStackTrace(this, this.constructor); //super helper method to include stack trace in error object\n\n  this.name = this.constructor.name; //set our function’s name as error name.\n  this.message = message || 'Error with scan';\n}\nutil.inherits(ScanError, Error);\n\n\nfunction ValidationError(message) {\n  Error.call(this); //super constructor\n  Error.captureStackTrace(this, this.constructor); //super helper method to include stack trace in error object\n\n  this.name = this.constructor.name; //set our function’s name as error name.\n  this.message = message || 'Validation error';\n}\nutil.inherits(ValidationError, Error);\n\n\n\nmodule.exports.SchemaError = SchemaError;\nmodule.exports.ModelError = ModelError;\nmodule.exports.QueryError = QueryError;\nmodule.exports.ScanError = ScanError;\nmodule.exports.ValidationError = ValidationError;","/home/travis/build/npmtest/node-npmtest-dynamoose/node_modules/dynamoose/lib/VirtualType.js":"\n\nvar debug = require('debug')('dynamoose:virtualtype');\n\n/**\n * VirtualType constructor\n *\n * This is what mongoose uses to define virtual attributes via `Schema.prototype.virtual`.\n *\n * ####Example:\n *\n *     var fullname = schema.virtual('fullname');\n *     fullname instanceof mongoose.VirtualType // true\n *\n * @parma {Object} options\n * @api public\n */\n\nfunction VirtualType (options, name) {\n  this.path = name;\n  this.options = options || {};\n}\n\n/**\n * Defines a getter.\n *\n * ####Example:\n *\n *     var virtual = schema.virtual('fullname');\n *     virtual.get(function () {\n *       return this.name.first + ' ' + this.name.last;\n *     });\n *\n * @param {Function} fn\n * @return {VirtualType} this\n * @api public\n */\n\nVirtualType.prototype.get = function (fn) {\n  debug('registering getter for ' + this.path);\n  this.getter = fn;\n  return this;\n};\n\n/**\n * Defines a setter.\n *\n * ####Example:\n *\n *     var virtual = schema.virtual('fullname');\n *     virtual.set(function (v) {\n *       var parts = v.split(' ');\n *       this.name.first = parts[0];\n *       this.name.last = parts[1];\n *     });\n *\n * @param {Function} fn\n * @return {VirtualType} this\n * @api public\n */\n\nVirtualType.prototype.set = function (fn) {\n  debug('registering setter for ' + this.path);\n  this.setter = fn;\n  return this;\n};\n\n\n/**\n * Applies getters and setters to the model\n * @param {Object} model\n * @return {any} the value after applying all getters\n * @api public\n */\nVirtualType.prototype.applyVirtuals = function (model) {\n    debug('applyVirtuals for %s', this.path);\n    var property = {enumerable: true,\n                    configurable: true};\n\n    if (this.setter){\n      property.set = this.setter;\n    }\n\n    if (this.getter){\n      property.get = this.getter;\n    }\n\n    Object.defineProperty(model, this.path, property);\n};\n\n/*!\n * exports\n */\n\nmodule.exports = VirtualType;\n","/home/travis/build/npmtest/node-npmtest-dynamoose/node_modules/dynamoose/lib/Model.js":"'use strict';\nvar util = require('util');\nvar Q = require('q');\nvar hooks = require('hooks');\nvar Table = require('./Table');\nvar Query = require('./Query');\nvar Scan = require('./Scan');\nvar errors = require('./errors');\n\n//var MAX_BATCH_READ_SIZE   = 100;\nvar MAX_BATCH_WRITE_SIZE  = 25;\nvar debug = require('debug')('dynamoose:model');\n\nfunction Model(obj) {\n  this.$__.isNew = true;\n\n  for(var key in obj) {\n    this[key] = obj[key];\n  }\n}\n\nfunction processCondition(req, options, schema) {\n  if (options.condition) {\n    if(req.ConditionExpression) {\n      req.ConditionExpression = '(' + req.ConditionExpression + ') and (' + options.condition + ')';\n    } else {\n      req.ConditionExpression = options.condition;\n    }\n\n    if(options.conditionNames) {\n      req.ExpressionAttributeNames = {};\n      for(var name in options.conditionNames) {\n        req.ExpressionAttributeNames['#' + name] = options.conditionNames[name];\n      }\n    }\n    if(options.conditionValues) {\n      req.ExpressionAttributeValues = {};\n      Object.keys(options.conditionValues).forEach(function (k) {\n        var val = options.conditionValues[k];\n        var attr = schema.attributes[k];\n        if(attr) {\n          req.ExpressionAttributeValues[':' + k] = attr.toDynamo(val);\n        } else {\n          throw new errors.ModelError('Invalid condition value: ' + k + '. The name must either be in the schema or a full DynamoDB object must be specified.');\n        }\n      });\n    }\n  }\n}\n\nModel.compile = function compile (name, schema, options, base) {\n  debug('compiling NewModel %s', name);\n\n  var table = new Table(name, schema, options, base);\n\n  /*jshint validthis: true */\n  function NewModel (obj) {\n    Model.call(this, obj);\n    applyVirtuals(this, schema);\n  }\n\n  util.inherits(NewModel, Model);\n\n  // minimize what is restricted\n  NewModel.prototype.$__ = {\n    table: table,\n    base: base,\n    name: name,\n    schema: schema,\n    options: options\n  };\n  NewModel.$__ = NewModel.prototype.$__;\n\n  NewModel.get = function (key, options, next) {\n    return Model.get(NewModel, key, options, next);\n  };\n\n  NewModel.update = function (key, update, options, next) {\n    return Model.update(NewModel, key, update, options, next);\n  };\n\n  NewModel.delete = function (key, options, next) {\n    return Model.delete(NewModel, key, options, next);\n  };\n\n  NewModel.query = function (query, options, next) {\n    return Model.query(NewModel, query, options, next);\n  };\n\n  NewModel.queryOne = function (query, options, next) {\n    return Model.queryOne(NewModel, query, options, next);\n  };\n\n  NewModel.scan = function (filter, options, next) {\n    return Model.scan(NewModel, filter, options, next);\n  };\n\n  NewModel.create = function (obj, options, next) {\n    return Model.create(NewModel, obj, options, next);\n  };\n\n  NewModel.batchGet = function (keys, options, next) {\n    return Model.batchGet(NewModel, keys, options, next);\n  };\n\n  NewModel.batchPut = function (keys, options, next) {\n    return Model.batchPut(NewModel, keys, options, next);\n  };\n\n  NewModel.batchDelete = function (keys, options, next) {\n    return Model.batchDelete(NewModel, keys, options, next);\n  };\n\n  NewModel.waitForActive = function (timeout, next) {\n    return table.waitForActive(timeout, next);\n  };\n\n\n  // apply methods and statics\n  applyMethods(NewModel, schema);\n  applyStatics(NewModel, schema);\n\n  // set up middleware\n  for (var k in hooks) {\n    NewModel[k] = hooks[k];\n  }\n\n  table.init(function (err) {\n    if(err) {\n      throw err;\n    }\n  });\n\n  return NewModel;\n};\n\n\n/*!\n * Register methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n */\nvar applyMethods = function(model, schema) {\n  debug('applying methods');\n  for (var i in schema.methods) {\n    model.prototype[i] = schema.methods[i];\n  }\n};\n\n/*!\n * Register statics for this model\n * @param {Model} model\n * @param {Schema} schema\n */\nvar applyStatics = function(model, schema) {\n  debug('applying statics');\n  for (var i in schema.statics) {\n    model[i] = schema.statics[i];\n   }\n};\n\n/*!\n * Register virtuals for this model\n * @param {Model} model\n * @param {Schema} schema\n */\nvar applyVirtuals = function(model, schema){\n  debug('applying virtuals');\n  for (var i in schema.virtuals){\n    schema.virtuals[i].applyVirtuals(model);\n  }\n};\n\n\n\n\nModel.prototype.put = function(options, next) {\n  debug('put', this);\n  var deferred = Q.defer();\n  options = options || {};\n  if(typeof options === 'function') {\n    next = options;\n    options = {};\n  }\n  if(options.overwrite === null || options.overwrite === undefined) {\n    options.overwrite = true;\n  }\n\n  var schema = this.$__.schema;\n  var item = {\n    TableName: this.$__.name\n  };\n  try {\n    item.Item = schema.toDynamo(this);\n  } catch(err) {\n    deferred.reject(err);\n    return deferred.promise.nodeify(next);\n  }\n\n  if(!options.overwrite) {\n    item.ConditionExpression = 'attribute_not_exists(' + schema.hashKey.name + ')';\n  }\n  processCondition(item, options, this.$__.schema);\n\n  debug('putItem', item);\n\n  var model = this;\n  var model$ = this.$__;\n\n  function put() {\n    model$.base.ddb().putItem(item, function(err) {\n      if(err) {\n        deferred.reject(err);\n      }\n      deferred.resolve(model);\n    });\n\n    return deferred.promise.nodeify(next);\n  }\n\n\n  if(model$.options.waitForActive) {\n    return model$.table.waitForActive().then(put);\n  }\n\n  return put();\n\n\n};\n\nModel.prototype.save = Model.prototype.put;\n\nModel.create = function(NewModel, obj, options, next) {\n  options = options || {};\n\n  if(typeof options === 'function') {\n    next = options;\n    options = {};\n  }\n\n  if(options.overwrite === null || options.overwrite === undefined) {\n    options.overwrite = false;\n  }\n\n  var model = new NewModel(obj);\n  return model.save(options, next);\n};\n\nModel.get = function(NewModel, key, options, next) {\n  debug('Get %j', key);\n  var deferred = Q.defer();\n  if(key === null || key === undefined) {\n    deferred.reject(new errors.ModelError('Key required to get item'));\n    return deferred.promise.nodeify(next);\n  }\n  options = options || {};\n  if(typeof options === 'function') {\n    next = options;\n    options = {};\n  }\n\n  var schema = NewModel.$__.schema;\n\n  var hashKeyName = schema.hashKey.name;\n  if(!key[hashKeyName]) {\n    var keyVal = key;\n    key = {};\n    key[hashKeyName] = keyVal;\n  }\n\n  if(schema.rangeKey && !key[schema.rangeKey.name]) {\n    deferred.reject(\n      new errors.ModelError('Range key required: ' + schema.rangeKey.name)\n    );\n    return deferred.promise.nodeify(next);\n  }\n\n\n  var getReq = {\n    TableName: NewModel.$__.name,\n    Key: {}\n  };\n\n  try {\n    getReq.Key[hashKeyName] = schema.hashKey.toDynamo(key[hashKeyName]);\n\n    if(schema.rangeKey) {\n      var rangeKeyName = schema.rangeKey.name;\n      getReq.Key[rangeKeyName] = schema.rangeKey.toDynamo(key[rangeKeyName]);\n    }\n  } catch (err) {\n    deferred.reject(err);\n    return deferred.promise.nodeify(next);\n  }\n\n  if(options.attributes) {\n    getReq.AttributesToGet = options.attributes;\n  }\n\n  if(options.consistent) {\n    getReq.ConsistentRead = true;\n  }\n\n  var newModel$ = NewModel.$__;\n\n  function get () {\n    debug('getItem', getReq);\n    newModel$.base.ddb().getItem(getReq, function(err, data) {\n      if(err) {\n        debug('Error returned by getItem', err);\n        return deferred.reject(err);\n      }\n      // console.log('RESP',JSON.stringify(data, null, 4));\n      debug('getItem response', data);\n\n      if(!Object.keys(data).length) {\n        return deferred.resolve();\n      }\n\n      try {\n        var model = new NewModel();\n\n        model.$__.isNew = false;\n        schema.parseDynamo(model, data.Item);\n\n        debug('getItem parsed model', model);\n\n        deferred.resolve(model);\n      } catch (err) {\n        deferred.reject(err);\n      }\n    });\n  }\n\n\n  if(newModel$.options.waitForActive) {\n    newModel$.table.waitForActive().then(get);\n  } else {\n    get();\n  }\n  return deferred.promise.nodeify(next);\n};\n\n/* NewModel.update({id: 123},\n// {\n//   $PUT: {a: 1, b: 2},\n//   $DELETE: {c: 'a'},\n//   $ADD: {count: 1}\n// });\n// NewModel.update({id: 123}, { $PUT: {a: 1, b: 2} });\n// NewModel.update({id: 123}, {a: 1, b: 2} ); // Defaults to put (same as above)*/\nModel.update = function(NewModel, key, update, options, next) {\n  debug('Update %j', key);\n  var deferred = Q.defer();\n  if(key === null || key === undefined) {\n    deferred.reject(new errors.ModelError('Key required to get item'));\n    return deferred.promise.nodeify(next);\n  }\n  options = options || {};\n  if(typeof options === 'function') {\n    next = options;\n    options = {};\n  }\n\n  var schema = NewModel.$__.schema;\n\n  var hashKeyName = schema.hashKey.name;\n  if(!key[hashKeyName]) {\n    var keyVal = key;\n    key = {};\n    key[hashKeyName] = keyVal;\n  }\n\n  if(schema.rangeKey && !key[schema.rangeKey.name]) {\n    deferred.reject(new errors.ModelError('Range key required: ' + schema.rangeKey.name));\n    return deferred.promise.nodeify(next);\n  }\n\n\n  var updateReq = {\n    TableName: NewModel.$__.name,\n    Key: {},\n    ExpressionAttributeNames: {},\n    ExpressionAttributeValues: {},\n    ReturnValues: 'ALL_NEW'\n  };\n  processCondition(updateReq, options, NewModel.$__.schema);\n\n  try {\n    updateReq.Key[hashKeyName] = schema.hashKey.toDynamo(key[hashKeyName]);\n\n    if(schema.rangeKey) {\n      var rangeKeyName = schema.rangeKey.name;\n      updateReq.Key[rangeKeyName] = schema.rangeKey.toDynamo(key[rangeKeyName]);\n    }\n  } catch(err) {\n    deferred.reject(err);\n    return deferred.promise.nodeify(next);\n  }\n\n  // determine the set of operations to be executed\n  var operations = {\n    SET: {},\n    ADD: {},\n    REMOVE: {}\n  };\n  if(update.$PUT || (!update.$PUT && !update.$DELETE && !update.$ADD)) {\n    var updatePUT = update;\n    if(update.$PUT) {\n      updatePUT = update.$PUT;\n    }\n    for(var putItem in updatePUT) {\n      var putAttr = schema.attributes[putItem];\n      if(putAttr) {\n        var val = updatePUT[putItem];\n\n        var removeParams = val === null || val === undefined || val === '';\n\n        if (!options.allowEmptyArray) {\n          removeParams = removeParams || (Array.isArray(val) && val.length === 0);\n        }\n\n        if(removeParams) {\n          operations.REMOVE[putItem] = null;\n        } else {\n          try {\n            operations.SET[putItem] = putAttr.toDynamo(val);\n          } catch (err) {\n            deferred.reject(err);\n            return deferred.promise.nodeify(next);\n          }\n        }\n      }\n    }\n  }\n\n  if(update.$DELETE) {\n    for(var deleteItem in update.$DELETE) {\n      var deleteAttr = schema.attributes[deleteItem];\n      if(deleteAttr) {\n        var delVal = update.$DELETE[deleteItem];\n        if(delVal !== null && delVal !== undefined) {\n          try {\n            operations.REMOVE[deleteItem] = deleteAttr.toDynamo(delVal);\n          } catch (err) {\n            deferred.reject(err);\n            return deferred.promise.nodeify(next);\n          }\n        } else {\n          operations.REMOVE[deleteItem] = null;\n        }\n      }\n    }\n  }\n\n  if(update.$ADD) {\n    for(var addItem in update.$ADD) {\n      var addAttr = schema.attributes[addItem];\n      if(addAttr) {\n        try {\n          operations.ADD[addItem] = addAttr.toDynamo(update.$ADD[addItem]);\n        } catch (err) {\n          deferred.reject(err);\n          return deferred.promise.nodeify(next);\n        }\n      }\n    }\n  }\n\n  // construct the update expression\n  //\n  // we have to use update expressions because we are supporting\n  // condition expressions, and you can't mix expressions with\n  // non-expressions\n  var attrCount = 0;\n  updateReq.UpdateExpression = '';\n  var first, k;\n  for(var op in operations) {\n    if(Object.keys(operations[op]).length) {\n      if (updateReq.UpdateExpression) {\n        updateReq.UpdateExpression += ' ';\n      }\n      updateReq.UpdateExpression += op + ' ';\n      first = true;\n      for(k in operations[op]) {\n        if(first) {\n          first = false;\n        } else {\n          updateReq.UpdateExpression += ',';\n        }\n        var attrName = '#_n' + attrCount;\n        var valName = ':_p' + attrCount;\n        updateReq.UpdateExpression += attrName;\n        updateReq.ExpressionAttributeNames[attrName] = k;\n        if(operations[op][k]) {\n          updateReq.UpdateExpression += ' ' + (op === 'SET' ? '= ' : '') + valName;\n          updateReq.ExpressionAttributeValues[valName] = operations[op][k];\n        }\n        attrCount += 1;\n      }\n    }\n  }\n\n  // AWS doesn't allow empty expressions or attribute collections\n  if(!updateReq.UpdateExpression) {\n    delete updateReq.UpdateExpression;\n  }\n  if(!Object.keys(updateReq.ExpressionAttributeNames).length) {\n    delete updateReq.ExpressionAttributeNames;\n  }\n  if(!Object.keys(updateReq.ExpressionAttributeValues).length) {\n    delete updateReq.ExpressionAttributeValues;\n  }\n\n  var newModel$ = NewModel.$__;\n\n  function updateItem () {\n    debug('updateItem', updateReq);\n    newModel$.base.ddb().updateItem(updateReq, function(err, data) {\n      if(err) {\n        debug('Error returned by updateItem', err);\n        return deferred.reject(err);\n      }\n      debug('updateItem response', data);\n\n      if(!Object.keys(data).length) {\n        return deferred.resolve();\n      }\n\n      var model = new NewModel();\n      model.$__.isNew = false;\n      schema.parseDynamo(model, data.Attributes);\n\n      debug('updateItem parsed model', model);\n\n      deferred.resolve(model);\n    });\n  }\n\n  if(newModel$.options.waitForActive) {\n    newModel$.table.waitForActive().then(updateItem);\n  } else {\n    updateItem();\n  }\n\n  return deferred.promise.nodeify(next);\n};\n\nModel.delete = function(NewModel, key, options, next) {\n\n  var schema = NewModel.$__.schema;\n\n  var hashKeyName = schema.hashKey.name;\n  if(!key[hashKeyName]) {\n    var keyVal = key;\n    key = {};\n    key[hashKeyName] = keyVal;\n  }\n\n  if(schema.rangeKey && !key[schema.rangeKey.name]) {\n    var deferred = Q.defer();\n    deferred.reject(new errors.ModelError('Range key required: %s', schema.hashKey.name));\n    return deferred.promise.nodeify(next);\n  }\n\n  var model = new NewModel(key);\n  return model.delete(options, next);\n};\n\nModel.prototype.delete = function(options, next) {\n  options = options || {};\n  if(typeof options === 'function') {\n    next = options;\n    options = {};\n  }\n\n  var schema = this.$__.schema;\n\n  var hashKeyName = schema.hashKey.name;\n\n  var deferred = Q.defer();\n\n  if(this[hashKeyName] === null || this[hashKeyName] === undefined) {\n    deferred.reject(new errors.ModelError('Hash key required: %s', hashKeyName));\n    return deferred.promise.nodeify(next);\n  }\n\n  if(schema.rangeKey &&\n    (this[schema.rangeKey.name] === null || this[schema.rangeKey.name] === undefined)) {\n    deferred.reject(new errors.ModelError('Range key required: %s', schema.hashKey.name));\n    return deferred.promise.nodeify(next);\n  }\n\n\n  var getDelete = {\n    TableName: this.$__.name,\n    Key: {}\n  };\n\n  try {\n    getDelete.Key[hashKeyName] = schema.hashKey.toDynamo(this[hashKeyName]);\n\n    if(schema.rangeKey) {\n      var rangeKeyName = schema.rangeKey.name;\n      getDelete.Key[rangeKeyName] = schema.rangeKey.toDynamo(this[rangeKeyName]);\n    }\n  } catch (err) {\n    deferred.reject(err);\n    return deferred.promise.nodeify(next);\n  }\n\n  if(options.update) {\n    getDelete.ReturnValues = 'ALL_OLD';\n    getDelete.ConditionExpression = 'attribute_exists(' + schema.hashKey.name + ')';\n  }\n\n  var model = this;\n  var model$ = this.$__;\n\n  function deleteItem() {\n\n    debug('deleteItem', getDelete);\n    model$.base.ddb().deleteItem(getDelete, function(err, data) {\n      if(err) {\n        debug('Error returned by deleteItem', err);\n        return deferred.reject(err);\n      }\n      debug('deleteItem response', data);\n\n      if(options.update) {\n        if(data.Attributes) {\n          schema.parseDynamo(model, data.Attributes);\n          debug('deleteItem parsed model', model);\n        }\n      }\n\n      deferred.resolve(model);\n    });\n  }\n\n  if(model$.options.waitForActive) {\n    model$.table.waitForActive().then(deleteItem);\n  } else {\n    deleteItem();\n  }\n\n  return deferred.promise.nodeify(next);\n\n};\n\n/*\nquery(query, options, callback);\nquery(query, options)...exec(callback);\nquery(query, callback);\nquery(query)...exec(callback);\nquery({hash: {id: {eq : 1}}, range: {name: {beginwith: 'foxy'}}})\nquery({id: 1})\nquery('id').eq(1).where('name').begienwith('foxy')\n*/\nModel.query = function(NewModel, query, options, next) {\n  if(typeof options === 'function') {\n    next = options;\n    options = null;\n  }\n\n  query = new Query(NewModel, query, options);\n\n  if(next) {\n    query.exec(next);\n  }\n\n  return query;\n};\n\nModel.queryOne = function(NewModel, query, options, next) {\n  if(typeof options === 'function') {\n    next = options;\n    options = null;\n  }\n\n  query = new Query(NewModel, query, options);\n  query.one();\n\n  if(next) {\n    query.exec(next);\n  }\n\n  return query;\n};\n\n\n/*\n\nscan(filter, options, callback);\nscan(filter, options)...exec(callback);\nscan(filter, callback);\nscan(filter)...exec(callback);\n\nscan('id').between(a, b).and().where('name').begienwith('foxy').exec();\n\nscan().exec(); // All records\n\n*/\nModel.scan = function(NewModel, filter, options, next) {\n  if(typeof options === 'function') {\n    next = options;\n    options = null;\n  }\n\n  var scan = new Scan(NewModel, filter, options);\n\n  if(next) {\n    scan.exec(next);\n  }\n\n  return scan;\n};\n\nModel.batchGet = function(NewModel, keys, options, next) {\n  debug('BatchGet %j', keys);\n  var deferred = Q.defer();\n  if(!(keys instanceof Array)) {\n    deferred.reject(new errors.ModelError('batchGet requires keys to be an array'));\n    return deferred.promise.nodeify(next);\n  }\n  options = options || {};\n  if(typeof options === 'function') {\n    next = options;\n    options = {};\n  }\n\n  var schema = NewModel.$__.schema;\n\n  var hashKeyName = schema.hashKey.name;\n  keys = keys.map(function (key) {\n    if(!key[hashKeyName]) {\n      var ret = {};\n      ret[hashKeyName] = key;\n      return ret;\n    }\n    return key;\n  });\n\n  if(schema.rangeKey && !keys.every(function (key) { return key[schema.rangeKey.name]; })) {\n    deferred.reject(\n      new errors.ModelError('Range key required: ' + schema.rangeKey.name)\n    );\n    return deferred.promise.nodeify(next);\n  }\n\n  var batchReq = {\n    RequestItems: {}\n  };\n\n  var getReq = {};\n  batchReq.RequestItems[NewModel.$__.name] = getReq;\n\n  getReq.Keys = keys.map(function (key) {\n    var ret = {};\n    ret[hashKeyName] = schema.hashKey.toDynamo(key[hashKeyName]);\n\n    if(schema.rangeKey) {\n      var rangeKeyName = schema.rangeKey.name;\n      ret[rangeKeyName] = schema.rangeKey.toDynamo(key[rangeKeyName]);\n    }\n    return ret;\n  });\n\n  if(options.attributes) {\n    getReq.AttributesToGet = options.attributes;\n  }\n\n  if(options.consistent) {\n    getReq.ConsistentRead = true;\n  }\n\n  var newModel$ = NewModel.$__;\n\n  function batchGet () {\n    debug('batchGetItem', batchReq);\n    newModel$.base.ddb().batchGetItem(batchReq, function(err, data) {\n      if(err) {\n        debug('Error returned by batchGetItem', err);\n        return deferred.reject(err);\n      }\n      debug('batchGetItem response', data);\n\n      if(!Object.keys(data).length) {\n        return deferred.resolve();\n      }\n\n      function toModel (item) {\n        var model = new NewModel();\n        model.$__.isNew = false;\n        schema.parseDynamo(model, item);\n\n        debug('batchGet parsed model', model);\n\n        return model;\n      }\n\n      var models = data.Responses[newModel$.name] ? data.Responses[newModel$.name].map(toModel) : [];\n      if (data.UnprocessedKeys[newModel$.name]) {\n        // convert unprocessed keys back to dynamoose format\n        models.unprocessed = data.UnprocessedKeys[newModel$.name].Keys.map(function (key) {\n          var ret = {};\n          ret[hashKeyName] = schema.hashKey.parseDynamo(key[hashKeyName]);\n\n          if(schema.rangeKey) {\n            var rangeKeyName = schema.rangeKey.name;\n            ret[rangeKeyName] = schema.rangeKey.parseDynamo(key[rangeKeyName]);\n          }\n          return ret;\n        });\n      }\n      deferred.resolve(models);\n    });\n  }\n\n\n  if(newModel$.options.waitForActive) {\n    newModel$.table.waitForActive().then(batchGet);\n  } else {\n    batchGet();\n  }\n  return deferred.promise.nodeify(next);\n};\n\nfunction toBatchChunks(modelName, list, chunkSize, requestMaker) {\n  var listClone = list.slice(0);\n  var chunk = [];\n  var batchChunks = [];\n\n  while ((chunk = listClone.splice(0, chunkSize)).length) {\n    var requests = chunk.map(requestMaker);\n    var batchReq = {\n      RequestItems: {}\n    };\n\n    batchReq.RequestItems[modelName] = requests;\n    batchChunks.push(batchReq);\n  }\n\n  return batchChunks;\n}\n\nfunction reduceBatchResult(resultList) {\n\n  return resultList.reduce(function(acc, res) {\n    var responses = res.Responses ? res.Responses : {};\n    var unprocessed = res.UnprocessedItems ? res.UnprocessedItems : {};\n\n    // merge responses\n    for (var tableName in responses) {\n        if (responses.hasOwnProperty(tableName)) {\n            var consumed = acc.Responses[tableName] ? acc.Responses[tableName].ConsumedCapacityUnits : 0;\n            consumed += responses[tableName].ConsumedCapacityUnits;\n\n            acc.Responses[tableName] = {\n              ConsumedCapacityUnits: consumed\n            };\n        }\n    }\n\n    // merge unprocessed items\n    for (var tableName2 in unprocessed) {\n        if (unprocessed.hasOwnProperty(tableName2)) {\n            var items = acc.UnprocessedItems[tableName2] ? acc.UnprocessedItems[tableName2] : [];\n            items.push(unprocessed[tableName2]);\n            acc.UnprocessedItems[tableName2] = items;\n        }\n    }\n\n    return acc;\n  }, {Responses: {}, UnprocessedItems: {}});\n}\n\nfunction batchWriteItems (NewModel, batchRequests) {\n  debug('batchWriteItems');\n  var newModel$ = NewModel.$__;\n\n  var batchList = batchRequests.map(function (batchReq) {\n    var deferredBatch = Q.defer();\n\n    newModel$.base.ddb().batchWriteItem(batchReq, function(err, data) {\n      if(err) {\n        debug('Error returned by batchWriteItems', err);\n        return deferredBatch.reject(err);\n      }\n\n      deferredBatch.resolve(data);\n    });\n\n    return deferredBatch.promise;\n  });\n\n  return Q.all(batchList).then(function (resultList) {\n    return reduceBatchResult(resultList);\n  });\n}\n\nModel.batchPut = function(NewModel, items, options, next) {\n  debug('BatchPut %j', items);\n  var deferred = Q.defer();\n\n  if(!(items instanceof Array)) {\n    deferred.reject(new errors.ModelError('batchPut requires items to be an array'));\n    return deferred.promise.nodeify(next);\n  }\n  options = options || {};\n  if(typeof options === 'function') {\n    next = options;\n    options = {};\n  }\n\n  var schema = NewModel.$__.schema;\n  var newModel$ = NewModel.$__;\n\n  var batchRequests = toBatchChunks(newModel$.name, items, MAX_BATCH_WRITE_SIZE, function(item) {\n    return {\n      PutRequest: {\n        Item: schema.toDynamo(item)\n      }\n    };\n  });\n\n  var batchPut = function() {\n    batchWriteItems(NewModel, batchRequests).then(function (result) {\n      deferred.resolve(result);\n    }).fail(function (err) {\n      deferred.reject(err);\n    });\n  };\n\n  if(newModel$.options.waitForActive) {\n    newModel$.table.waitForActive().then(batchPut);\n  } else {\n    batchPut();\n  }\n  return deferred.promise.nodeify(next);\n};\n\nModel.batchDelete = function(NewModel, keys, options, next) {\n  debug('BatchDel %j', keys);\n  var deferred = Q.defer();\n\n  if(!(keys instanceof Array)) {\n    deferred.reject(new errors.ModelError('batchDelete requires keys to be an array'));\n    return deferred.promise.nodeify(next);\n  }\n\n  options = options || {};\n  if(typeof options === 'function') {\n    next = options;\n    options = {};\n  }\n\n  var schema = NewModel.$__.schema;\n  var newModel$ = NewModel.$__;\n  var hashKeyName = schema.hashKey.name;\n\n  var batchRequests = toBatchChunks(newModel$.name, keys, MAX_BATCH_WRITE_SIZE, function(key) {\n    var key_element = {};\n    key_element[hashKeyName] = schema.hashKey.toDynamo(key[hashKeyName]);\n\n    if(schema.rangeKey) {\n      key_element[schema.rangeKey.name] = schema.rangeKey.toDynamo(key[schema.rangeKey.name]);\n    }\n\n    return {\n      DeleteRequest: {\n        Key: key_element\n      }\n    };\n  });\n\n  var batchDelete = function() {\n    batchWriteItems(NewModel, batchRequests).then(function (result) {\n      deferred.resolve(result);\n    }).fail(function (err) {\n      deferred.reject(err);\n    });\n  };\n\n  if(newModel$.options.waitForActive) {\n    newModel$.table.waitForActive().then(batchDelete);\n  } else {\n    batchDelete();\n  }\n  return deferred.promise.nodeify(next);\n};\n\nmodule.exports = Model;\n","/home/travis/build/npmtest/node-npmtest-dynamoose/node_modules/dynamoose/lib/Table.js":"'use strict';\nvar Q = require('q');\nvar debug = require('debug')('dynamoose:table');\nvar util = require('util');\nvar _ = require('underscore');\n\nfunction Table(name, schema, options, base) {\n  debug('new Table (%s)', name, schema);\n  this.name = name;\n  this.schema = schema;\n  this.options = options || {};\n  this.base = base;\n\n  if (this.options.create === undefined || this.options.create === null) {\n    this.options.create = true;\n  }\n}\n\nvar compareIndexes = function compareIndexes(local, remote) {\n  var indexes = {\n    delete: [],\n    create: [],\n    both: []\n  };\n  var localTableReq = local;\n  var remoteTableReq = remote;\n  var i;\n  var j;\n\n  var localIndexes = localTableReq.GlobalSecondaryIndexes || [];\n  var remoteIndexes = remoteTableReq.GlobalSecondaryIndexes || [];\n\n  debug('compareIndexes');\n  // let's see what remote indexes we need to sync or create\n  for (i = 0; i < localIndexes.length; i++) {\n    var remoteIndexFound = false;\n    for (j = 0; j < remoteIndexes.length; j++) {\n      if (remoteIndexes[j].IndexName === localIndexes[i].IndexName) {\n        // let's see if the core data matches. if it doesn't,\n        // we may need to delete the remote GSI and rebuild.\n        var localIndex = _.pick(localIndexes[i], 'IndexName', 'KeySchema', 'Projection', 'ProvisionedThroughput');\n        var remoteIndex = _.pick(remoteIndexes[j], 'IndexName', 'KeySchema', 'Projection', 'ProvisionedThroughput');\n        if (remoteIndex.hasOwnProperty('ProvisionedThroughput')) {\n          delete remoteIndex.ProvisionedThroughput.NumberOfDecreasesToday;\n        }\n\n        if (!_.isEqual(remoteIndex, localIndex)) {\n          indexes.both.push(localIndex);\n          remoteIndexFound = true;\n        } else {\n          remoteIndexFound = true;\n        }\n      }\n    }\n    if (!remoteIndexFound) {\n      indexes.create.push(localIndexes[i]);\n    }\n  }\n  for (j = 0; j < remoteIndexes.length; j++) {\n    var localExists = false;\n    for (i = 0; i < localIndexes.length; i++) {\n      if (remoteIndexes[j].IndexName === localIndexes[i].IndexName) {\n        localExists = true;\n      }\n    }\n    if (!localExists) {\n      indexes.delete.push(remoteIndexes[j]);\n    }\n  }\n  // now let's see what remote indexes exist that shouldn't exist\n\n  return indexes;\n};\n\nTable.prototype.deleteIndex = function deleteIndex(indexName) {\n  var deferred = Q.defer();\n  var table = this;\n  table.active = false;\n  var params = {\n    TableName: table.name,\n    GlobalSecondaryIndexUpdates: [\n      {\n        Delete: {\n          IndexName: indexName\n        }\n      }\n    ]\n  };\n  table.base.ddb().updateTable(params, function (err, data) {\n    debug('deleteIndex handler running');\n    if (err) {\n      deferred.reject(err);\n    }\n    else {\n      setTimeout(function () {\n        table.waitForActive()\n          .then(function () {\n            deferred.resolve(data);\n          });\n      }, 300);\n    }\n  });\n  return deferred.promise;\n};\n\nTable.prototype.createIndex = function createIndex(attributes, indexSpec) {\n  var deferred = Q.defer();\n  var table = this;\n  table.active = false;\n  var params = {\n    TableName: this.name,\n    AttributeDefinitions: attributes,\n    GlobalSecondaryIndexUpdates: [\n      {\n        Create: indexSpec\n      }\n    ]\n  };\n  this.base.ddb().updateTable(params, function (err, data) {\n    if (err) {\n      deferred.reject(err);\n    }\n    else {\n      setTimeout(function () {\n        table.waitForActive()\n          .then(function () {\n            deferred.resolve(data);\n          });\n      }, 300);\n    }\n  });\n  return deferred.promise;\n};\n\nTable.prototype.init = function (next) {\n  debug('initializing table, %s, %j', this.name, this.options);\n  var deferred = Q.defer();\n\n  var table = this;\n  var localTableReq;\n\n  if (this.options.create) {\n    this.describe()\n      .then(function (data) {\n        debug('table exist -- initialization done');\n        localTableReq = buildTableReq(table.name, table.schema);\n        var indexes = compareIndexes(localTableReq, data.Table);\n\n        debug('%s', JSON.stringify(indexes, null, 2));\n        if (table.options.update) {\n          debug('checking indexes');\n          for (var deleteIdx in indexes.delete) {\n            table.deleteIndex(indexes.delete[deleteIdx].IndexName);\n          }\n          for (var bothIdx in indexes.both) {\n            /*jshint loopfunc: true */\n            table.deleteIndex(indexes.both[bothIdx].IndexName)\n              .then(function () {\n                table.createIndex(localTableReq.AttributeDefinitions, indexes.both[bothIdx]);\n              });\n          }\n          for (var createIdx in indexes.create) {\n            table.createIndex(localTableReq.AttributeDefinitions, indexes.create[createIdx]);\n          }\n        } else {\n          if (indexes.delete.length > 0 || indexes.create.length > 0) {\n            debug('indexes are not synchronized and update flag is set to false');\n            deferred.reject('indexes are not synchronized and update flag is set to false');\n          }\n        }\n        table.initialized = true;\n        return table.waitForActive()\n          .then(function () {\n            //table.active = data.Table.TableStatus === 'ACTIVE';\n\n            return deferred.resolve();\n          });\n      })\n      .catch(function (err) {\n        if (err && err.code === 'ResourceNotFoundException') {\n          debug('table does not exist -- creating');\n          return deferred.resolve(\n            table.create()\n              .then(function () {\n                table.initialized = true;\n              })\n              .then(function() {\n                if(table.options.waitForActive) {\n                  return table.waitForActive();\n                }\n              })\n          );\n        }\n        if (err) {\n          debug('error initializing', err.stack);\n          return deferred.reject(err);\n        }\n      });\n  } else {\n    table.initialized = true;\n    return deferred.resolve();\n  }\n  return deferred.promise.nodeify(next);\n};\n\nTable.prototype.waitForActive = function (timeout, next) {\n  debug('Waiting for Active table, %s, %j', this.name, this.options);\n  var deferred = Q.defer();\n\n  if (typeof timeout === 'function') {\n    next = timeout;\n    timeout = null;\n  }\n\n  if (!timeout) {\n    timeout = this.options.waitForActiveTimeout;\n  }\n\n  var table = this;\n\n  var timeoutAt = Date.now() + timeout;\n\n  function waitForActive() {\n    debug('Waiting...');\n    /*\n     if (table.active) {\n     debug('Table flag is set to Active - %s', table.name);\n     return deferred.resolve();\n     }*/\n    if (Date.now() > timeoutAt) {\n      return deferred.reject(\n        new Error('Wait for Active timed out after ' + timeout + ' ms.')\n      );\n    }\n    if (!table.initialized) {\n      return setTimeout(waitForActive, 10);\n    }\n    table.describe()\n      .then(function (data) {\n        var active = (data.Table.TableStatus === 'ACTIVE');\n        var indexes = data.Table.GlobalSecondaryIndexes || [];\n        indexes.forEach(function (gsi) {\n          //debug('waitForActive Index Check: %s', JSON.stringify(gsi, null, 2));\n          debug('index %s.IndexStatus is %s', gsi.IndexName, gsi.IndexStatus);\n          if (gsi.IndexStatus !== 'ACTIVE') {\n            active = false;\n          }\n        });\n        if (!active) {\n          debug('Waiting for Active again - %s', table.name);\n          setTimeout(waitForActive, 500);\n        } else {\n          table.active = true;\n          deferred.resolve();\n        }\n      })\n      .catch(function (err) {\n        if (err && err.code === 'ResourceNotFoundException') {\n          return setTimeout(waitForActive, 10);\n        }\n        debug('Error waiting for active', err.stack);\n        return deferred.reject(err);\n      });\n  }\n\n  waitForActive();\n\n  return deferred.promise.nodeify(next);\n};\n\nTable.prototype.describe = function (next) {\n  var describeTableReq = {\n    TableName: this.name\n  };\n\n  var deferred = Q.defer();\n\n  var ddb = this.base.ddb();\n  ddb.describeTable(describeTableReq, function (err, data) {\n    if (err) {\n      debug('error describing table', err);\n      return deferred.reject(err);\n    }\n    deferred.resolve(data);\n  });\n\n\n  return deferred.promise.nodeify(next);\n};\n\nvar buildTableReq = function buildTableReq(name, schema) {\n  var attrDefs = [];\n\n  var keyAttr = {};\n\n  function addKeyAttr(attr) {\n    if (attr) {\n      keyAttr[attr.name] = attr;\n    }\n  }\n\n  addKeyAttr(schema.hashKey);\n  addKeyAttr(schema.rangeKey);\n  for (var globalIndexName in schema.indexes.global) {\n    addKeyAttr(schema.indexes.global[globalIndexName]);\n\n    // add the range key to the attribute definitions if specified\n    var rangeKeyName = schema.indexes.global[globalIndexName].indexes[globalIndexName].rangeKey;\n    addKeyAttr(schema.attributes[rangeKeyName]);\n  }\n  for (var indexName in schema.indexes.local) {\n    addKeyAttr(schema.indexes.local[indexName]);\n  }\n\n  for (var keyAttrName in keyAttr) {\n    attrDefs.push({\n      AttributeName: keyAttrName,\n      AttributeType: keyAttr[keyAttrName].type.dynamo\n    });\n  }\n\n\n  var keySchema = [{\n    AttributeName: schema.hashKey.name,\n    KeyType: 'HASH'\n  }];\n  if (schema.rangeKey) {\n    keySchema.push({\n      AttributeName: schema.rangeKey.name,\n      KeyType: 'RANGE'\n    });\n  }\n\n  var provThroughput = {\n    ReadCapacityUnits: schema.throughput.read,\n    WriteCapacityUnits: schema.throughput.write\n  };\n\n  var createTableReq = {\n    AttributeDefinitions: attrDefs,\n    TableName: name,\n    KeySchema: keySchema,\n    ProvisionedThroughput: provThroughput\n  };\n\n  debug('Creating table local indexes', schema.indexes.local);\n  var localSecIndexes, index;\n  for (var localSecIndexName in schema.indexes.local) {\n    localSecIndexes = localSecIndexes || [];\n\n    var indexAttr = schema.indexes.local[localSecIndexName];\n    index = indexAttr.indexes[localSecIndexName];\n    var localSecIndex = {\n      IndexName: localSecIndexName,\n      KeySchema: [{\n        AttributeName: schema.hashKey.name,\n        KeyType: 'HASH'\n      }, {\n        AttributeName: indexAttr.name,\n        KeyType: 'RANGE'\n      }]\n    };\n\n    if (index.project) {\n      if (util.isArray(index.project)) {\n        localSecIndex.Projection = {\n          ProjectionType: 'INCLUDE',\n          NonKeyAttributes: index.project\n        };\n      } else {\n        localSecIndex.Projection = {\n          ProjectionType: 'ALL'\n        };\n      }\n    } else {\n      localSecIndex.Projection = {\n        ProjectionType: 'KEYS_ONLY'\n      };\n    }\n\n    localSecIndexes.push(localSecIndex);\n  }\n\n\n  var globalSecIndexes;\n  for (var globalSecIndexName in schema.indexes.global) {\n    globalSecIndexes = globalSecIndexes || [];\n\n    var globalIndexAttr = schema.indexes.global[globalSecIndexName];\n    index = globalIndexAttr.indexes[globalSecIndexName];\n\n    var globalSecIndex = {\n      IndexName: globalSecIndexName,\n      KeySchema: [{\n        AttributeName: globalIndexAttr.name,\n        KeyType: 'HASH'\n      }],\n      ProvisionedThroughput: {\n        ReadCapacityUnits: index.throughput.read,\n        WriteCapacityUnits: index.throughput.write\n      }\n    };\n\n\n    if (index.rangeKey) {\n      globalSecIndex.KeySchema.push({\n        AttributeName: index.rangeKey,\n        KeyType: 'RANGE'\n      });\n    }\n\n    if (index.project) {\n      if (util.isArray(index.project)) {\n        globalSecIndex.Projection = {\n          ProjectionType: 'INCLUDE',\n          NonKeyAttributes: index.project\n        };\n      } else {\n        globalSecIndex.Projection = {\n          ProjectionType: 'ALL'\n        };\n      }\n    } else {\n      globalSecIndex.Projection = {\n        ProjectionType: 'KEYS_ONLY'\n      };\n    }\n\n    globalSecIndexes.push(globalSecIndex);\n  }\n\n  if (localSecIndexes) {\n    createTableReq.LocalSecondaryIndexes = localSecIndexes;\n  }\n\n  if (globalSecIndexes) {\n    createTableReq.GlobalSecondaryIndexes = globalSecIndexes;\n  }\n\n  return createTableReq;\n};\n\nTable.prototype.create = function (next) {\n  var ddb = this.base.ddb();\n  var schema = this.schema;\n  var createTableReq = buildTableReq(this.name, schema);\n\n  debug('ddb.createTable request:', createTableReq);\n\n  var deferred = Q.defer();\n\n  ddb.createTable(createTableReq, function (err, data) {\n    if (err) {\n      debug('error creating table', err);\n      return deferred.reject(err);\n    }\n    debug('table created', data);\n    deferred.resolve(data);\n  });\n  return deferred.promise.nodeify(next);\n\n};\n\nTable.prototype.delete = function (next) {\n  var deleteTableReq = {\n    TableName: this.name\n  };\n\n  debug('ddb.deleteTable request:', deleteTableReq);\n\n  var ddb = this.base.ddb();\n\n  var deferred = Q.defer();\n\n  ddb.deleteTable(deleteTableReq, function (err, data) {\n    if (err) {\n      debug('error deleting table', err);\n      return deferred.reject(err);\n    }\n    debug('deleted table', data);\n    deferred.resolve(data);\n  });\n\n  return deferred.promise.nodeify(next);\n\n};\n\nTable.prototype.update = function (next) {\n  // var ddb = this.base.ddb();\n  // ddb.updateTable();\n  var deferred = Q.defer();\n  deferred.reject(new Error('TODO'));\n  return deferred.promise.nodeify(next);\n};\n\nmodule.exports = Table;\n","/home/travis/build/npmtest/node-npmtest-dynamoose/node_modules/dynamoose/lib/Query.js":"'use strict';\nvar Q = require('q');\nvar errors = require('./errors');\nvar debug = require('debug')('dynamoose:query');\n\n\n\nfunction Query (Model, query, options) {\n  this.Model = Model;\n  this.options = options || {};\n\n\n  // {\n  //   hashKey: {\n  //     name: 'name',\n  //     value: 'value'\n  //   },\n  //   rangeKey: {\n  //     name: 'name',\n  //     value: 'value',\n  //     comparison: 'string'\n  //   }\n  // }\n  this.query = {hashKey: {}};\n\n  this.filters = {};\n  this.buildState = false;\n\n  var hashKeyName, hashKeyVal;\n  if(typeof query === 'string') {\n    this.buildState = 'hashKey';\n    this.query.hashKey.name = query;\n  } else if (query.hash) {\n    hashKeyName = Object.keys(query.hash)[0];\n    hashKeyVal = query.hash[hashKeyName];\n    if(hashKeyVal.eq !== null && hashKeyVal.eq !== undefined) {\n      hashKeyVal = hashKeyVal.eq;\n    }\n    this.query.hashKey.name = hashKeyName;\n    this.query.hashKey.value = hashKeyVal;\n\n    if(query.range) {\n      var rangeKeyName = Object.keys(query.range)[0];\n      var rangeKeyVal = query.range[rangeKeyName];\n      var rangeKeyComp = Object.keys(rangeKeyVal)[0];\n      rangeKeyVal = rangeKeyVal[rangeKeyComp];\n      this.query.rangeKey = {\n        name: rangeKeyName,\n        value: rangeKeyVal,\n        comparison: rangeKeyComp\n      };\n    }\n  } else {\n    hashKeyName = Object.keys(query)[0];\n    hashKeyVal = query[hashKeyName];\n    if(hashKeyVal.eq !== null && hashKeyVal.eq !== undefined) {\n      hashKeyVal = hashKeyVal.eq;\n    }\n    this.query.hashKey.name = hashKeyName;\n    this.query.hashKey.value = hashKeyVal;  }\n}\n\n\n\nQuery.prototype.exec = function (next) {\n  debug('exec query for ', this.query);\n  var Model = this.Model;\n  var Model$ = Model.$__;\n  var schema = Model$.schema;\n  var options = this.options;\n\n  debug('Query with schema', schema);\n\n  var queryReq = {\n    TableName: Model.$__.name,\n    KeyConditions: {}\n  };\n\n  var indexName, index;\n  if(schema.hashKey.name !== this.query.hashKey.name) {\n    debug('query is on global secondary index');\n    for(indexName in schema.indexes.global) {\n      index = schema.indexes.global[indexName];\n      if(index.name === this.query.hashKey.name) {\n        debug('using index', indexName);\n        queryReq.IndexName = indexName;\n        break;\n      }\n    }\n\n  }\n\n  var hashAttr = schema.attributes[this.query.hashKey.name];\n\n  queryReq.KeyConditions[this.query.hashKey.name] = {\n    AttributeValueList: [hashAttr.toDynamo(this.query.hashKey.value)],\n    ComparisonOperator: 'EQ'\n  };\n\n  var i, val;\n\n  if(this.query.rangeKey) {\n    var rangeKey = this.query.rangeKey;\n    var rangeAttr = schema.attributes[rangeKey.name];\n\n    if(!queryReq.IndexName && schema.rangeKey.name !== rangeKey.name) {\n      debug('query is on local secondary index');\n      for(indexName in schema.indexes.local) {\n        index = schema.indexes.local[indexName];\n        if(index.name === rangeKey.name) {\n          debug('using local index', indexName);\n          queryReq.IndexName = indexName;\n          break;\n        }\n      }\n    }\n\n    if(!rangeKey || rangeKey.values === undefined) {\n      debug('No range key value (i.e. get all)');\n    } else {\n      debug('Range key: %s', rangeKey.name);\n      var keyConditions = queryReq.KeyConditions[rangeKey.name] = {\n        AttributeValueList: [],\n        ComparisonOperator: rangeKey.comparison.toUpperCase()\n      };\n      for (i = 0; i < rangeKey.values.length; i++) {\n        val = rangeKey.values [i];\n        keyConditions.AttributeValueList.push(\n          rangeAttr.toDynamo(val, true)\n        );\n      }\n    }\n  }\n\n\n  if(this.filters && Object.keys(this.filters).length > 0) {\n    queryReq.QueryFilter = {};\n    for(var name in this.filters) {\n      debug('Filter on: %s', name);\n      var filter = this.filters[name];\n      var filterAttr = schema.attributes[name];\n      queryReq.QueryFilter[name] = {\n        AttributeValueList: [],\n        ComparisonOperator: filter.comparison.toUpperCase()\n      };\n\n      if(filter.values) {\n        for (i = 0; i < filter.values.length; i++) {\n          val = filter.values[i];\n          queryReq.QueryFilter[name].AttributeValueList.push(\n            filterAttr.toDynamo(val, true)\n          );\n        }\n      }\n    }\n  }\n\n  if(options.or) {\n    queryReq.ConditionalOperator = 'OR'; // defualts to AND\n  }\n\n  if(options.attributes) {\n    queryReq.AttributesToGet = options.attributes;\n  }\n\n  if(options.consistent) {\n    queryReq.ConsistentRead = true;\n  }\n\n  if(options.limit) {\n    queryReq.Limit = options.limit;\n  }\n\n  if(options.one) {\n    queryReq.Limit = 1;\n  }\n\n  if(options.descending) {\n    queryReq.ScanIndexForward = false;\n  }\n\n  if(options.ExclusiveStartKey) {\n    queryReq.ExclusiveStartKey = options.ExclusiveStartKey;\n  }\n\n\n  function query () {\n    var deferred = Q.defer();\n\n    debug('DynamoDB Query: %j', queryReq);\n    Model$.base.ddb().query(queryReq, function(err, data) {\n      if(err) {\n        debug('Error returned by query', err);\n        return deferred.reject(err);\n      }\n      debug('DynamoDB Query Response: %j', data);\n\n      if(!Object.keys(data).length) {\n        return deferred.resolve();\n      }\n\n      function toModel (item) {\n        var model = new Model();\n        model.$__.isNew = false;\n        schema.parseDynamo(model, item);\n\n        debug('query parsed model', model);\n\n        return model;\n      }\n\n      try {\n\n        var models = data.Items.map(toModel);\n\n        if(options.one) {\n          if (!models || models.length === 0) {\n            return deferred.resolve();\n          }\n          return deferred.resolve(models[0]);\n        }\n\n        models.lastKey = data.LastEvaluatedKey;\n        deferred.resolve(models);\n\n      } catch (err) {\n        deferred.reject(err);\n      }\n    });\n\n    return deferred.promise.nodeify(next);\n  }\n\n\n  if(Model$.options.waitForActive) {\n    return Model$.table.waitForActive().then(query);\n  }\n\n  return query();\n};\n\n\nQuery.prototype.where = function (rangeKey) {\n  if(this.buildState) {\n    throw new errors.QueryError('Invalid query state; where() must follow eq()');\n  }\n  if(typeof rangeKey === 'string') {\n    this.buildState = 'rangeKey';\n    this.query.rangeKey = {name: rangeKey};\n  } else {\n    var rangeKeyName = Object.keys(rangeKey)[0];\n    var rangeKeyVal = rangeKey[rangeKeyName];\n    var rangeKeyComp = Object.keys(rangeKeyVal)[0];\n    rangeKeyVal = rangeKeyVal[rangeKeyComp];\n    this.query.rangeKey = {\n      name: rangeKeyName,\n      values: [rangeKeyVal],\n      comparison: rangeKeyComp\n    };\n  }\n\n  return this;\n};\n\nQuery.prototype.filter = function (filter) {\n  if(this.buildState) {\n    throw new errors.QueryError('Invalid query state; filter() must follow comparison');\n  }\n  if(typeof filter === 'string') {\n    this.buildState = 'filter';\n    this.currentFilter = filter;\n    if(this.filters[filter]) {\n      throw new errors.QueryError('Invalid query state; %s filter can only be used once', filter);\n    }\n    this.filters[filter] = {name: filter};\n  }\n\n  return this;\n};\n\nvar VALID_RANGE_KEYS = ['EQ', 'LE', 'LT', 'GE', 'GT', 'BEGINS_WITH', 'BETWEEN'];\nQuery.prototype.compVal = function (vals, comp) {\n  if(this.buildState === 'hashKey') {\n    if(comp !== 'EQ') {\n      throw new errors.QueryError('Invalid query state; eq must follow query()');\n    }\n    this.query.hashKey.value = vals[0];\n  } else if (this.buildState === 'rangeKey'){\n    if(VALID_RANGE_KEYS.indexOf(comp) < 0) {\n      throw new errors.QueryError('Invalid query state; %s must follow filter()', comp);\n    }\n    this.query.rangeKey.values = vals;\n    this.query.rangeKey.comparison = comp;\n  } else if (this.buildState === 'filter') {\n    this.filters[this.currentFilter].values = vals;\n    this.filters[this.currentFilter].comparison = comp;\n  } else {\n    throw new errors.QueryError('Invalid query state; %s must follow query(), where() or filter()', comp);\n  }\n\n  this.buildState = false;\n  this.notState = false;\n\n  return this;\n};\n\nQuery.prototype.and = function() {\n  this.options.or = false;\n\n  return this;\n};\n\nQuery.prototype.or = function() {\n  this.options.or = true;\n\n  return this;\n};\n\nQuery.prototype.not = function() {\n  this.notState = true;\n  return this;\n};\n\nQuery.prototype.null = function() {\n  if(this.notState) {\n    return this.compVal(null, 'NOT_NULL');\n  } else {\n    return this.compVal(null, 'NULL');\n  }\n};\n\n\nQuery.prototype.eq = function (val) {\n  if(this.notState) {\n    return this.compVal([val], 'NE');\n  } else {\n    return this.compVal([val], 'EQ');\n  }\n};\n\n\nQuery.prototype.lt = function (val) {\n  if(this.notState) {\n    return this.compVal([val], 'GE');\n  } else {\n    return this.compVal([val], 'LT');\n  }\n};\n\nQuery.prototype.le = function (val) {\n  if(this.notState) {\n    return this.compVal([val], 'GT');\n  } else {\n    return this.compVal([val], 'LE');\n  }\n};\n\nQuery.prototype.ge = function (val) {\n  if(this.notState) {\n    return this.compVal([val], 'LT');\n  } else {\n    return this.compVal([val], 'GE');\n  }\n};\n\nQuery.prototype.gt = function (val) {\n  if(this.notState) {\n    return this.compVal([val], 'LE');\n  } else {\n    return this.compVal([val], 'GT');\n  }\n};\n\nQuery.prototype.contains = function (val) {\n  if(this.notState) {\n    return this.compVal([val], 'NOT_CONTAINS');\n  } else {\n    return this.compVal([val], 'CONTAINS');\n  }\n};\n\nQuery.prototype.beginsWith = function (val) {\n  if(this.notState) {\n    throw new errors.QueryError('Invalid Query state: beginsWith() cannot follow not()');\n  }\n  return this.compVal([val], 'BEGINS_WITH');\n};\n\nQuery.prototype.in = function (vals) {\n  if(this.notState) {\n    throw new errors.QueryError('Invalid Query state: in() cannot follow not()');\n  }\n\n  return this.compVal(vals, 'IN');\n};\n\nQuery.prototype.between = function (a, b) {\n  if(this.notState) {\n    throw new errors.QueryError('Invalid Query state: between() cannot follow not()');\n  }\n  return this.compVal([a, b], 'BETWEEN');\n};\n\n\nQuery.prototype.limit = function (limit) {\n  this.options.limit = limit;\n  return this;\n};\n\n\nQuery.prototype.one = function () {\n  this.options.one = true;\n  return this;\n};\n\nQuery.prototype.consistent = function () {\n  this.options.consistent = true;\n  return this;\n};\n\nQuery.prototype.descending = function () {\n  this.options.descending = true;\n  return this;\n};\n\n\nQuery.prototype.ascending = function () {\n  this.options.descending = false;\n  return this;\n};\n\nQuery.prototype.startAt = function (key) {\n  this.options.ExclusiveStartKey = key;\n  return this;\n};\n\nQuery.prototype.attributes = function (attributes) {\n  this.options.attributes = attributes;\n  return this;\n};\n\n\n\nmodule.exports = Query;\n","/home/travis/build/npmtest/node-npmtest-dynamoose/node_modules/dynamoose/lib/Scan.js":"'use strict';\nvar Q = require('q');\nvar debug = require('debug')('dynamoose:scan');\n\nvar errors = require('./errors');\nfunction Scan (Model, filter, options) {\n\n  this.Model = Model;\n  this.options = options || {};\n\n\n  // [{\n  //     name: 'name',\n  //     values: ['value', ...],\n  //     comparison: 'string'\n  //   },\n  //    ...\n  // ]\n  this.filters = {};\n  this.buildState = false;\n\n  if (typeof filter === 'string') {\n    this.buildState = filter;\n    this.filters[filter] = {name: filter};\n  } else if (typeof filter === 'object'){\n    this.parseFilterObject(filter);\n  }\n}\n\n\n\nScan.prototype.exec = function (next) {\n  debug('exec scan for ', this.scan);\n  var Model = this.Model;\n  var Model$ = Model.$__;\n  var schema = Model$.schema;\n  var options = this.options;\n\n  var scanReq = {\n    TableName: Model.$__.name\n  };\n\n  if(Object.keys(this.filters).length > 0) {\n    scanReq.ScanFilter = {};\n    for(var name in this.filters) {\n      var filter = this.filters[name];\n      var filterAttr = schema.attributes[name];\n      scanReq.ScanFilter[name] = {\n        AttributeValueList: [],\n        ComparisonOperator: filter.comparison\n      };\n\n      if(filter.values) {\n        for (var i = 0; i < filter.values.length; i++) {\n          var val = filter.values[i];\n          scanReq.ScanFilter[name].AttributeValueList.push(\n            filterAttr.toDynamo(val, true)\n          );\n        }\n      }\n    }\n  }\n\n  if(options.attributes) {\n    scanReq.AttributesToGet = options.attributes;\n  }\n\n  if(options.limit) {\n    scanReq.Limit = options.limit;\n  }\n\n  if(options.ExclusiveStartKey) {\n    scanReq.ExclusiveStartKey = options.ExclusiveStartKey;\n  }\n\n  if(options.conditionalOperator) {\n    scanReq.ConditionalOperator = options.conditionalOperator;\n  }\n\n  function scan () {\n    var deferred = Q.defer();\n\n    debug('scan request', scanReq);\n    Model.$__.base.ddb().scan(scanReq, function(err, data) {\n      if(err) {\n        debug('Error returned by scan', err);\n        return deferred.reject(err);\n      }\n      debug('scan response', data);\n\n      if(!Object.keys(data).length) {\n        return deferred.resolve();\n      }\n\n      function toModel (item) {\n        var model = new Model();\n        model.$__.isNew = false;\n        schema.parseDynamo(model, item);\n\n        debug('scan parsed model', model);\n\n        return model;\n      }\n\n      try {\n        var models = data.Items.map(toModel);\n\n        models.lastKey = data.LastEvaluatedKey;\n        deferred.resolve(models);\n      } catch (err) {\n        deferred.reject(err);\n      }\n    });\n\n    return deferred.promise.nodeify(next);\n  }\n\n\n  if(Model$.options.waitForActive) {\n    return Model$.table.waitForActive().then(scan);\n  }\n\n  return scan();\n};\n\nScan.prototype.parseFilterObject = function (filter) {\n\n  if (Object.keys(filter).length > 0) {\n\n    for(var filterName in filter) {\n      if (filter.hasOwnProperty(filterName)) {\n\n        // Parse AND OR\n        if (filterName === 'and' || filterName === 'or') {\n\n          this[filterName]();\n          for(var condition in filter[filterName]) {\n            if (filter[filterName].hasOwnProperty(condition)) {\n              this.parseFilterObject(filter[filterName][condition]);\n            }\n          }\n        } else {\n\n          this.where(filterName);\n          var val, comp;\n\n          if (typeof filter[filterName] === 'object' &&\n            Object.keys(filter[filterName]).length  === 1) {\n\n            comp = Object.keys(filter[filterName])[0];\n\n            if (comp === 'null') {\n              if (!filter[filterName][comp]) {\n                comp = 'not_null';\n              }\n              val = [null];\n            } else if (comp === 'in' || comp === 'between') {\n              val = filter[filterName][comp];\n            } else {\n              val = [filter[filterName][comp]];\n            }\n\n          } else {\n            comp = 'eq';\n            val = [filter[filterName]];\n          }\n          this.compVal(val, comp.toUpperCase());\n        }\n\n\n      }\n    }\n  }\n};\n\nScan.prototype.and = function() {\n  this.options.conditionalOperator = 'AND';\n  return this;\n};\n\nScan.prototype.or = function() {\n  this.options.conditionalOperator = 'OR';\n  return this;\n};\n\n\nScan.prototype.where = function (filter) {\n  if(this.buildState) {\n    throw new errors.ScanError('Invalid scan state; where() must follow comparison');\n  }\n  if(typeof filter === 'string') {\n    this.buildState = filter;\n    if(this.filters[filter]) {\n      throw new errors.ScanError('Invalid scan state; %s can only be used once', filter);\n    }\n    this.filters[filter] = {name: filter};\n  }\n\n  return this;\n};\nScan.prototype.filter = Scan.prototype.where;\n\nScan.prototype.compVal = function (vals, comp) {\n\n  var permittedComparison =\n    [\n      'NOT_NULL','NULL','EQ','NE','GE','LT','GT','LE','GE',\n      'NOT_CONTAINS','CONTAINS','BEGINS_WITH','IN','BETWEEN'\n    ];\n\n\n  if(!this.buildState) {\n    throw new errors.ScanError('Invalid scan state; %s must follow scan(), where(), or filter()', comp);\n  }\n\n  if (permittedComparison.indexOf(comp) === -1) {\n    throw new errors.ScanError('Invalid comparison %s', comp);\n  }\n\n  this.filters[this.buildState].values = vals;\n  this.filters[this.buildState].comparison = comp;\n\n  this.buildState = false;\n  this.notState = false;\n\n  return this;\n};\n\n\nScan.prototype.not = function() {\n  this.notState = true;\n  return this;\n};\n\nScan.prototype.null = function() {\n  if(this.notState) {\n    return this.compVal(null, 'NOT_NULL');\n  } else {\n    return this.compVal(null, 'NULL');\n  }\n};\n\n\nScan.prototype.eq = function (val) {\n  if(this.notState) {\n    return this.compVal([val], 'NE');\n  } else {\n    return this.compVal([val], 'EQ');\n  }\n};\n\n\nScan.prototype.lt = function (val) {\n  if(this.notState) {\n    return this.compVal([val], 'GE');\n  } else {\n    return this.compVal([val], 'LT');\n  }\n};\n\nScan.prototype.le = function (val) {\n  if(this.notState) {\n    return this.compVal([val], 'GT');\n  } else {\n    return this.compVal([val], 'LE');\n  }\n};\n\nScan.prototype.ge = function (val) {\n  if(this.notState) {\n    return this.compVal([val], 'LT');\n  } else {\n    return this.compVal([val], 'GE');\n  }\n};\n\nScan.prototype.gt = function (val) {\n  if(this.notState) {\n    return this.compVal([val], 'LE');\n  } else {\n    return this.compVal([val], 'GT');\n  }\n};\n\nScan.prototype.contains = function (val) {\n  if(this.notState) {\n    return this.compVal([val], 'NOT_CONTAINS');\n  } else {\n    return this.compVal([val], 'CONTAINS');\n  }\n};\n\nScan.prototype.beginsWith = function (val) {\n  if(this.notState) {\n    throw new errors.ScanError('Invalid scan state: beginsWith() cannot follow not()');\n  }\n  return this.compVal([val], 'BEGINS_WITH');\n};\n\nScan.prototype.in = function (vals) {\n  if(this.notState) {\n    throw new errors.ScanError('Invalid scan state: in() cannot follow not()');\n  }\n\n  return this.compVal(vals, 'IN');\n};\n\nScan.prototype.between = function (a, b) {\n  if(this.notState) {\n    throw new errors.ScanError('Invalid scan state: between() cannot follow not()');\n  }\n  return this.compVal([a, b], 'BETWEEN');\n};\n\nScan.prototype.limit = function (limit) {\n  this.options.limit = limit;\n  return this;\n};\n\nScan.prototype.startAt = function (key) {\n  this.options.ExclusiveStartKey = key;\n  return this;\n};\n\nScan.prototype.attributes = function (attributes) {\n  this.options.attributes = attributes;\n  return this;\n};\n\nmodule.exports = Scan;\n","/home/travis/build/npmtest/node-npmtest-dynamoose/node_modules/dynamoose/gruntfile.js":"'use strict';\nmodule.exports = function(grunt) {\n  grunt.initConfig({\n    pkg: grunt.file.readJSON('package.json'),\n    jshint: {\n      app: {\n        src: ['gruntfile.js', 'index.js', 'lib/**/*.js'],\n        options: {\n          node: true,\n          jshintrc: '.jshintrc'\n        }\n      },\n      test: {\n        src: ['test/**/*.js' ],\n        options: {\n          node: true,\n          jshintrc: 'test/.jshintrc'\n        }\n      }\n    },\n    mochaTest: {\n      test: {\n        options: {\n          reporter: 'spec'\n        },\n        src: ['test/**/*.js']\n      },\n      testCoverage: {\n        options: {\n          reporter: 'spec',\n          require: 'test/coverage/blanket'\n        },\n        src: ['test/**/*.js']\n      },\n      coverage: {\n        options: {\n          reporter: 'html-cov',\n          // use the quiet flag to suppress the mocha console output\n          quiet: true,\n          // specify a destination file to capture the mocha\n          // output (the quiet option does not suppress this)\n          captureFile: 'coverage.html'\n        },\n        src: ['test/**/*.js']\n      },\n      'travis-cov': {\n        options: {\n          reporter: 'travis-cov'\n        },\n        src: ['test/**/*.js']\n      }\n    }\n  });\n\n  // Load libs\n  grunt.loadNpmTasks('grunt-contrib-jshint');\n  grunt.loadNpmTasks('grunt-mocha-test');\n\n\n  // Register the default tasks\n  grunt.registerTask('default', ['jshint', 'mochaTest']);\n\n  grunt.registerTask('test', ['jshint', 'mochaTest:test']);\n\n  grunt.registerTask('coverage', ['jshint', 'mochaTest:testCoverage', 'mochaTest:coverage', 'mochaTest:travis-cov']);\n\n};"}